
# 1.2. DispatcherServlet.md
[Spring WebFlux와 동일](https://docs.spring.io/spring/docs/5.0.4.BUILD-SNAPSHOT/spring-framework-reference/web-reactive.html#webflux-dispatcher-handler)

많은 다른 웹 프레임 워크와 마찬가지로 Spring MVC는 프런트 컨트롤러 패턴을 중심으로 설계되었으며,  
DispatcherServlet 인 중앙 서블릿은 요청 처리를 위한 공유 알고리즘을 제공하고  
실제 작업은 구성 가능한 위임 구성 요소로 수행합니다.  
이 모델은 유연하고 다양한 워크 플로를 지원합니다.  


DispatcherServlet은 모든 서블릿과 마찬가지로 Java 구성 또는 web.xml을 사용하여  
서블릿 사양에 따라 선언하고 매핑해야합니다.  

DispatcherServlet은 Spring 구성을 사용하여  
[요청 매핑(request mapping), 뷰 분석(view resolution), 예외 처리(exception handling) 등](https://docs.spring.io/spring/docs/5.0.4.BUILD-SNAPSHOT/spring-framework-reference/web.html#mvc-servlet-special-bean-types)  
에 필요한 위임 구성 요소를 검색합니다.   


다음은 DispatcherServlet을 등록하고 초기화하는 Java 구성의 예입니다.  
이 클래스는 Servlet 컨테이너에 의해 자동 감지됩니다 ([Servlet Config 참조](https://docs.spring.io/spring/docs/5.0.4.BUILD-SNAPSHOT/spring-framework-reference/web.html#mvc-container-config)).  

~~~java
public class MyWebApplicationInitializer implements WebApplicationInitializer {

    @Override
    public void onStartup(ServletContext servletCxt) {

        // Load Spring web application configuration
        AnnotationConfigWebApplicationContext ac = new AnnotationConfigWebApplicationContext();
        ac.register(AppConfig.class);
        ac.refresh();

        // Create and register the DispatcherServlet
        DispatcherServlet servlet = new DispatcherServlet(ac);
        ServletRegistration.Dynamic registration = servletCxt.addServlet("app", servlet);
        registration.setLoadOnStartup(1);
        registration.addMapping("/app/*");
    }
}
~~~
---
> ServletContext API를 직접 사용하는 것 외에도  
> AbstractAnnotationConfigDispatcherServletInitializer를 확장하고  
> 특정 메서드를 재정의 할 수 있습니다 ([컨텍스트 계층 구조](https://docs.spring.io/spring/docs/5.0.4.BUILD-SNAPSHOT/spring-framework-reference/web.html#mvc-servlet-context-hierarchy)의 예제 참조).  
---

다음은 DispatcherServlet을 등록하고 초기화하는 web.xml 구성 예제입니다.  
~~~
<web-app>

    <listener>
        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
    </listener>

    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>/WEB-INF/app-context.xml</param-value>
    </context-param>

    <servlet>
        <servlet-name>app</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value></param-value>
        </init-param>
        <load-on-startup>1</load-on-startup>
    </servlet>

    <servlet-mapping>
        <servlet-name>app</servlet-name>
        <url-pattern>/app/*</url-pattern>
    </servlet-mapping>

</web-app>
~~~

---
> 스프링 부트는 다른 초기화 순서를 따른다.  
> SpringBoot는 Servlet 컨테이너의 라이프 사이클에 연결하는 대신  
> Spring 구성을 사용하여 자체 및 내장 된 Servlet 컨테이너를 부트 스트랩합니다.  
> 필터 및 서블릿 선언은 Spring 구성에서 감지되어 서블릿 컨테이너에 등록됩니다.  
> 자세한 내용은 [Spring Boot](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-embedded-container) 문서를 확인하십시오.  
---

## 1.2.1. Context Hierarchy
DispatcherServlet은 자신의 구성을 위해 일반 ApplicationContext의 확장 인 WebApplicationContext를 기대합니다.  
WebApplicationContext는 연관되어있는 ServletContext와 Servlet에 대한 링크를 가지고 있습니다.  
또한 ServletContext에 바인딩되어 있으므로 응용 프로그램에서  
RequestContextUtils의 정적 메서드를 사용하여 WebApplicationContext에 액세스해야하는 경우이를 조회 할 수 있습니다.  

* 단일 WebApplicationContext를 갖는 많은 응용 프로그램은 간단하고 충분(sufficient)합니다.  
* 하나의 루트 WebApplicationContext가  
여러 DispatcherServlet (또는 다른 Servlet) 인스턴스에서 공유되고  
각각 자체 Child WebApplicationContext 구성을 갖는 컨텍스트 계층 구조를 가질 수도 있습니다.  
컨텍스트 계층 구조 기능에 대한 자세한 내용은 [ApplicationContext의 추가 기능](https://docs.spring.io/spring/docs/5.0.4.BUILD-SNAPSHOT/spring-framework-reference/core.html#context-introduction)을 참조하십시오.  

루트 WebApplicationContext는  
일반적으로 여러 개의 Servlet 인스턴스에서 공유해야 하는 데이터 저장소 및 비즈니스 서비스와 같은 인프라 bean을 포함합니다.  
이러한 bean은 효과적으로 상속되며 서블릿 특정 클래스에서 재정의 (즉, 다시 선언) 될 수 있습니다.  
자식 WebApplicationContext는 일반적으로 주어진 지역의 빈을 포함합니다.  
![alt](docs/mvc-context-hierarchy.png)
