##### version: 5.1.2.RELEASE
[Spring Reference 1.4.1. Dependency Injection](https://docs.spring.io/spring/docs/5.1.2.RELEASE/spring-framework-reference/core.html#beans-factory-collaborators)

## 1.4.1. 의존성 주입

`DI(Dependency Injection)`는 **생성자 인수**, **팩토리 메소드**에 대한 인수 또는 구성 후  
**객체 인스턴스에 설정된 속성을 통해서만** 객체가 **종속성 (즉, 자신이 작업하는 다른 객체)을 정의하는 프로세스**입니다.  
**팩토리 메서드에서 반환**됩니다.  그런 다음 **컨테이너는 `Bean`을 작성할 때** 이러한 **종속성을 주입**합니다.  
이 프로세스는 기본적으로 클래스 직접 작성이나 또는 Service Locator 패턴을 사용하여    
Bean 자체의 의존성에 대한 인스턴스화 또는 위치를 제어하는 빈 자체의 역전(따라서 Inversion of Control)입니다.

코드는 **DI 원리로 보다 깔끔**하고, **디커플링은 객체가 의존성을 제공받을 때 더욱 효과적**입니다.  
**객체**는 **종속성을 찾지 않으며 종속성의 위치 나 클래스를 알지 못합니다.**  
따라서 종속성이 인터페이스 또는 추상 기본 클래스에있을 때 클래스 테스트가 쉬워져 단위 테스트에서 스텁 또는 모의 구현을 사용할 수 있습니다.  

DI는 크게 두 가지로 나뉩니다.  
**생성자 기반 종속성 주입**과 **Setter기반 종속성 주입**입니다.


### 생성자 기반 종속성 주입
**생성자 기반 DI**는 컨테이너가 여러 종속 변수를 나타내는 **여러 개의 인수**로 **생성자를 호출**함으로써 수행됩니다.  
`Bean`을 생성하기 위해 **특정 인자를 가진 정적 팩토리 메소드를 호출**하는 것은 ***거의 동일***하며,  
이 논의는 **생성자**와 **정적 팩토리 메소드**에 대한 ***인수를 유사하게 취급***합니다.  
다음 예제는 **생성자 주입으로 만 종속성 주입** 될 수 있는 클래스를 보여줍니다.  
~~~java
public class SimpleMovieLister {

    // SimpleMovieLister는 MovieFinder에 의존합니다.
    private MovieFinder movieFinder;

    // Spring 컨테이너가 MovieFinder를 생성자로 주입
    public SimpleMovieLister(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // 실제로 삽입 된 MovieFinder를 사용하는 비즈니스 로직은 생략합니다 ...
}
~~~

이 클래스에는 특별한 것이 없다는 것을 주목하십시오.  
이것은 **컨테이너 관련 인터페이스**, **기본 클래스** 또는 **주석**에 대한 **의존성이 없는 POJO**입니다.  

#### 생성자 인수 해결
**생성자 인수 확인 일치**는 **인수의 유형을 사용**하여 발생합니다.  
`bean` 정의의 생성자 인수에 잠재적 인 모호성이 없으면 `bean` 정의에서 생성자 인수가 정의되는 순서는  
**`bean`이 인스턴스화 될 때 해당 인수가 적절한 생성자에 제공되는 순서입니다.**  
다음 클래스를 고려하십시오.
~~~java
package x.y;

public class ThingOne {

    public ThingOne(ThingTwo thingTwo, ThingThree thingThree) {
        // ...
    }
}
~~~

`ThingTwo` 클래스와 `ThingThree` 클래스가 상속과 관련이 없다고 가정하면 잠재적 인 모호성은 없습니다.  
따라서 다음 구성이 제대로 작동하므로 **`<constructor-arg/>` 요소에 생성자 인수 인덱스 또는 유형을 명시 적으로 지정할 필요가 없습니다.**  
~~~xml
<beans>
    <bean id="thingOne" class="x.y.ThingOne">
        <constructor-arg ref="thingTwo"/>
        <constructor-arg ref="thingThree"/>
    </bean>

    <bean id="thingTwo" class="x.y.ThingTwo"/>

    <bean id="thingThree" class="x.y.ThingThree"/>
</beans>
~~~
다른 `bean`이 참조 될 때, 그 타입이 알려지고 일치가 발생할 수 있습니다.(앞의 예제와 마찬가지로)  
`<value>true</value>`와 같은 간단한 유형이 사용되면 `Spring`은 값의 유형을 판별 할 수 없으므로 **도움없이 유형별로 일치시킬 수 없습니다.**  
다음 클래스를 고려하십시오.  
~~~java
package examples;

public class ExampleBean {

    // 궁극적 인 답을 계산하는 년수
    private int years;

    // 생명, 우주, 그리고 모든 것에 대한 해답
    private String ultimateAnswer;

    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }
}
~~~

#### 생성자 인수 유형 일치
컨테이너는 `type` 특성을 사용하여 생성자 인수의 형식을 명시 적으로 지정하면 단순 형식과 일치하는 형식을 사용할 수 있습니다.  
다음 예제와 같이  
~~~xml
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg type="int" value="7500000"/>
    <constructor-arg type="java.lang.String" value="42"/>
</bean>
~~~
#### 생성자 인수 인덱스
다음 예제와 같이 **index 속성**을 사용하여 **생성자 인수의 인덱스를 명시 적으로 지정할 수 있습니다.**  
~~~xml
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg index="0" value="7500000"/>
    <constructor-arg index="1" value="42"/>
</bean>
~~~

여러 간단한 값의 모호성을 해결하는 것 외에도 **인덱스를 지정**하면 **생성자가 동일한 유형의 인수가 두 개인 모호성이 해결**됩니다.  

---
#### 중요
	인덱스는 0부터 시작합니다.
---

#### 생성자 인수 이름
다음 예제와 같이 **값 모호성 제거**에 **생성자 매개 변수 이름을 사용**할 수도 있습니다.
~~~xml
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg name="years" value="7500000"/>
    <constructor-arg name="ultimateAnswer" value="42"/>
</bean>
~~~
이 작업을 수행하려면 `Spring`에서 생성자의 매개 변수 이름을 찾을 수 있도록 디버그 플래그를 사용하도록 코드를 컴파일해야합니다.  
디버그 플래그로 코드를 컴파일 할 수 없거나 컴파일하지 않으려면 
[@ConstructorProperties](https://docs.oracle.com/javase/6/docs/api/java/beans/ConstructorProperties.html)
`JDK` 어노테이션을 사용하여  
생성자 인수의 이름을 명시 적으로 지정할 수 있습니다.  
샘플 클래스는 다음과 같이 보일 것입니다.  

~~~java
package examples;

public class ExampleBean {

    // 필드 생략

    @ConstructorProperties({"years", "ultimateAnswer"})
    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }
}
~~~


### Setter 기반 의존성 주입

**`Setter` 기반 `DI`** 는 **인수가없는 생성자** 또는 **빈을 인스턴스화 하기 위한 인수가 없는 정적 팩토리 메소드**를 호출 한 후  
`bean`에서 `setter` 메소드를 호출하는 컨테이너에 의해 수행됩니다.  

다음 예제에서는 **순수한 `Setter` 주입을 사용**하여 **종속성 주입 만 할 수있는 클래스**를 보여줍니다.  
이 클래스는 일반적인 Java입니다. 이것은 컨테이너 고유 인터페이스, 기본 클래스 또는 주석에 대한 종속성이없는 POJO입니다.  
~~~java
public class SimpleMovieLister {

    // SimpleMovieLister는 MovieFinder에 의존합니다.
    private MovieFinder movieFinder;

    // Spring 컨테이너가 MovieFinder를 삽입 할 수 있도록하는 setter 메소드
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // 실제로 삽입 된 MovieFinder를 사용하는 비즈니스 로직은 생략됩니다 ...
}
~~~
`ApplicationContext`는 자신이 관리하는 `bean`에 대한 **생성자 기반** 및 **`setter` 기반 DI**를 지원합니다.  
또한 **생성자 방식**을 통해 ***이미 일부 종속성이 주입 된 후에도*** **setter 기반 DI를 지원**합니다.  
`PropertyEditor` 인스턴스와 함께 사용하여 하나의 형식에서 다른 형식으로 속성을 변환하는 `BeanDefinition` 형식으로 종속성을 구성합니다.  
그러나 대부분의 `Spring` 사용자는 이러한 클래스를 직접 (프로그래밍 방식으로) 사용하지 않고  
`XML bean` 정의, 주석이 달린 구성 요소(즉, `@Component`, `@Controller` 등으로 주석 된 클래스)  
또는 `@Bean` 메소드를 사용한 `Java` 기반 `@Configuration` 클래스를 기반으로 합니다.  
이러한 소스는 내부적으로 `BeanDefinition`의 인스턴스로 변환되어 전체 `Spring IoC` 컨테이너 인스턴스를 로드하는 데 사용됩니다.  

생성자 기반 또는 setter 기반 DI?
**생성자 기반 및 setter 기반 DI를 혼합** 할 수 있으므로  
**필수 종속성 및 설정 메서드 또는 선택적 종속성에 대한 구성 메서드로** ***생성자를 사용하는 것이 좋습니다.***  
`setter` 메소드에서 **`@Required` 어노테이션**을 사용하면 속성을 **필수 종속성**으로 만들 수 있습니다.  

`Spring` 팀은 **일반적으로** 응용 프로그램 구성 요소를 **변경 불가능한 객체로 구현**하고  
**필요한 종속성이 null이 아닌지 확인하기 위해** ***생성자 삽입을 옹호합니다.***  
또한 **생성자가 주입 한 구성 요소**는 **완전히 초기화 된 상태**에서 항상 **클라이언트 (호출) 코드로 반환**됩니다.  
부수적으로, **많은 수의 생성자 인수**는 **나쁜 코드 냄새**이며, **클래스가 너무 많은 책임을 갖고 있으며 적절한 관심을 분리하기 위해  
리팩토링되어야 함을 의미합니다.**  

**`setter` 주입**은 주로 **클래스 내에서 적절한 기본값을 할당 할 수 있는** ***선택적 종속성에 대해서만 사용해야합니다.***  
그렇지 않으면 **코드에서 종속성을 사용하는 모든 곳**에서 **`null`이 아닌 검사를 수행**해야합니다.  
**`setter` 주입**의 한 가지 **이점**은 `setter` 메소드가 해당 클래스의 객체를 **나중에 재구성**하거나  
**다시 주입** 할 수있게 만드는 것입니다.  
따라서 [JMX MBeans](https://docs.spring.io/spring/docs/5.1.2.RELEASE/spring-framework-reference/integration.html#jmx)
를 통한 관리는 **세터 주입에 대한 매력적인 사용 사례**입니다.  

특정 클래스에 가장 적합한 `DI` 스타일을 사용하십시오.  
때로는 소스가없는 `third-party class`를 다룰 때 선택이 이루어집니다.  
예를 들어 `third-party class`가 **어떠한 `setter` 메소드도 노출시키지 않으면 생성자 주입이 `DI`의 유일하게 사용 가능한 형태** 일 수 있습니다.  

#### 종속성 해결 프로세스
컨테이너는 다음과 같이 Bean 의존성 분석을 수행합니다.  
- **`ApplicationContext`** 는 **모든 `bean`** 을 설명하는 **구성 메타 데이터로 작성되고 초기화**됩니다.
**구성 메타 데이터**는 **`XML`, `Java` 코드 또는 주석**으로 지정할 수 있습니다.
- 각 bean에 대해 종속성은 프로퍼티, 생성자 인수 또는 static-factory 메소드에 대한 인수 형식으로 표현됩니다(일반 생성자 대신이를 사용하는 경우).
이러한 종속성은 bean이 실제로 작성 될 때 bean에 제공됩니다.  
- 각 속성 또는 생성자 인수는 설정하려는 값의 실제 정의이거나 컨테이너의 다른 bean에 대한 참조입니다.  
- 값인 각 특성 또는 생성자 인수는 지정된 형식에서 해당 특성 또는 생성자 인수의 실제 유형으로 변환됩니다.
기본적으로, Spring은 문자열 형식으로 제공된 값을 int, long, String, boolean 등과 같은 모든 내장 유형으로 변환 할 수 있습니다.  



-



