##### version: 5.1.2.RELEASE
[Spring Reference 1.4.1. Dependency Injection](https://docs.spring.io/spring/docs/5.1.2.RELEASE/spring-framework-reference/core.html#beans-factory-collaborators)

## 1.4.1. 의존성 주입

`DI(Dependency Injection)`는 **생성자 인수**, **팩토리 메소드**에 대한 인수 또는 구성 후  
**객체 인스턴스에 설정된 속성을 통해서만** 객체가 **종속성 (즉, 자신이 작업하는 다른 객체)을 정의하는 프로세스**입니다.  
**팩토리 메서드에서 반환**됩니다.  그런 다음 **컨테이너는 `Bean`을 작성할 때** 이러한 **종속성을 주입**합니다.  
이 프로세스는 기본적으로 클래스 직접 작성이나 또는 Service Locator 패턴을 사용하여    
Bean 자체의 의존성에 대한 인스턴스화 또는 위치를 제어하는 빈 자체의 역전(따라서 Inversion of Control)입니다.

코드는 **DI 원리로 보다 깔끔**하고, **디커플링은 객체가 의존성을 제공받을 때 더욱 효과적**입니다.  
**객체**는 **종속성을 찾지 않으며 종속성의 위치 나 클래스를 알지 못합니다.**  
따라서 종속성이 인터페이스 또는 추상 기본 클래스에있을 때 클래스 테스트가 쉬워져 단위 테스트에서 스텁 또는 모의 구현을 사용할 수 있습니다.  

DI는 크게 두 가지로 나뉩니다.  
**생성자 기반 종속성 주입**과 **Setter기반 종속성 주입**입니다.


### 생성자 기반 종속성 주입
**생성자 기반 DI**는 컨테이너가 여러 종속 변수를 나타내는 **여러 개의 인수**로 **생성자를 호출**함으로써 수행됩니다.  
`Bean`을 생성하기 위해 **특정 인자를 가진 정적 팩토리 메소드를 호출**하는 것은 ***거의 동일***하며,  
이 논의는 **생성자**와 **정적 팩토리 메소드**에 대한 ***인수를 유사하게 취급***합니다.  
다음 예제는 **생성자 주입으로 만 종속성 주입** 될 수 있는 클래스를 보여줍니다.  
~~~java
public class SimpleMovieLister {

    // SimpleMovieLister는 MovieFinder에 의존합니다.
    private MovieFinder movieFinder;

    // Spring 컨테이너가 MovieFinder를 생성자로 주입
    public SimpleMovieLister(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // 실제로 삽입 된 MovieFinder를 사용하는 비즈니스 로직은 생략합니다 ...
}
~~~

이 클래스에는 특별한 것이 없다는 것을 주목하십시오.  
이것은 **컨테이너 관련 인터페이스**, **기본 클래스** 또는 **주석**에 대한 **의존성이 없는 POJO**입니다.  

#### 생성자 인수 해결
**생성자 인수 확인 일치**는 **인수의 유형을 사용**하여 발생합니다.  
`bean` 정의의 생성자 인수에 잠재적 인 모호성이 없으면 `bean` 정의에서 생성자 인수가 정의되는 순서는  
**`bean`이 인스턴스화 될 때 해당 인수가 적절한 생성자에 제공되는 순서입니다.**  
다음 클래스를 고려하십시오.
~~~java
package x.y;

public class ThingOne {

    public ThingOne(ThingTwo thingTwo, ThingThree thingThree) {
        // ...
    }
}
~~~

`ThingTwo` 클래스와 `ThingThree` 클래스가 상속과 관련이 없다고 가정하면 잠재적 인 모호성은 없습니다.  
따라서 다음 구성이 제대로 작동하므로 **`<constructor-arg/>` 요소에 생성자 인수 인덱스 또는 유형을 명시 적으로 지정할 필요가 없습니다.**  
~~~xml
<beans>
    <bean id="thingOne" class="x.y.ThingOne">
        <constructor-arg ref="thingTwo"/>
        <constructor-arg ref="thingThree"/>
    </bean>

    <bean id="thingTwo" class="x.y.ThingTwo"/>

    <bean id="thingThree" class="x.y.ThingThree"/>
</beans>
~~~
다른 `bean`이 참조 될 때, 그 타입이 알려지고 일치가 발생할 수 있습니다.(앞의 예제와 마찬가지로)  
`<value>true</value>`와 같은 간단한 유형이 사용되면 `Spring`은 값의 유형을 판별 할 수 없으므로 **도움없이 유형별로 일치시킬 수 없습니다.**  
다음 클래스를 고려하십시오.  
~~~java
package examples;

public class ExampleBean {

    // 궁극적 인 답을 계산하는 년수
    private int years;

    // 생명, 우주, 그리고 모든 것에 대한 해답
    private String ultimateAnswer;

    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }
}
~~~

#### 생성자 인수 유형 일치
컨테이너는 `type` 특성을 사용하여 생성자 인수의 형식을 명시 적으로 지정하면 단순 형식과 일치하는 형식을 사용할 수 있습니다.  
다음 예제와 같이  
~~~xml
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg type="int" value="7500000"/>
    <constructor-arg type="java.lang.String" value="42"/>
</bean>
~~~
#### 생성자 인수 인덱스
다음 예제와 같이 **index 속성**을 사용하여 **생성자 인수의 인덱스를 명시 적으로 지정할 수 있습니다.**  
~~~xml
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg index="0" value="7500000"/>
    <constructor-arg index="1" value="42"/>
</bean>
~~~

여러 간단한 값의 모호성을 해결하는 것 외에도 **인덱스를 지정**하면 **생성자가 동일한 유형의 인수가 두 개인 모호성이 해결**됩니다.  

---
#### 중요
	인덱스는 0부터 시작합니다.
---












