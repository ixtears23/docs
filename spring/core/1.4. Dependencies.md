# 1.4. Dependencies

일반적인 엔터프라이즈 애플리케이션은 단일객체(single object) (또는 Spring 용어의 bean)로 구성되지 않습니다.  
가장 간단한 응용 프로그램조차도 최종 사용자에게 일관된 응용 프로그램으로 보는 것을 제시하기 위해  
함께 작동하는 몇 가지 객체(object)가 있습니다.  
이 다음 절에서는 독립 실행 형 Bean 정의의 목표를 달성하기 위해  
오브젝트가 협업해서 응용 프로그램으로 migration 하는 방법에 대해 설명합니다.  

## 1.4.1. Dependency Injection
DI (Dependency Injection)는 객체가 종속성을 정의하는 프로세스입니다.  


DI 원리로 코드가 더 깨끗해지고 객체가 종속성을 제공받을 때 디커플링이 더 효과적입니다.  
**객체**는 **의존성을 찾지 않으며 의존성의 위치 나 클래스를 알지 못합니다.**  

**DI**는 **Constructor 기반 종속성 주입**과 **Setter 기반 종속성 주입**이라는 두 가지 주요 변종(variant)이 존재합니다.  

### Constructor-based dependency injection (생성자 기반 의존성 주입)

`Constructor-based DI(생성자 기반 DI)` 는 각각의 의존성을 나타내는  
여러개의 인자를 가진 생성자를 호출하는 컨테이너에 의해 수행된다.  

다음 예제는 **생성자 삽입으로 만 종속성 주입 될 수있는 클래스**를 보여줍니다.  
이 클래스에 특별한 것은 없으며 **컨테이너 고유의 인터페이스**, **기본 클래스** 또는 **annotation에 의존하지 않는 POJO**입니다.  
~~~java
public class SimpleMovieLister {

    // SimpleMovieLister는 MovieFinder에 의존합니다.
    private MovieFinder movieFinder;

    // Spring 컨테이너가 MovieFinder를 삽입 할 수 있도록 하는 생성자
    public SimpleMovieLister(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // 실제로 삽입 된 MovieFinder를 사용하는 비즈니스 로직은 생략됩니다 ...
}
~~~

#### Constructor argument resolution (생성자 인수 해결)
생성자 인수 해결 일치는 **인수의 유형을 사용**하여 발생합니다.  
bean 정의의 생성자 인수에 잠재적 인 모호성이 없다면,  
**Bean 정의**에서 **생성자 인수가 정의되는 순서**는  
**Bean이 인스턴스화 될 때 해당 인수가 적절한 생성자에 제공되는 순서**입니다.  

다음 클래스를 고려하십시오.
~~~java
package x.y;

public class Foo {

    public Foo(Bar bar, Baz baz) {
        // ...
    }
}
~~~

`Bar`와 `Baz` 클래스가 *상속과 관련이 없다고 가정 할 경우* **잠재적인 모호성이 없습니다.**
따라서 다음의 설정은 잘 동작하며  
`<constructor-arg />` 요소에서 명시 적으로 **생성자 인자 인덱스 및/또는 타입을 지정할 필요가 없습니다.**
~~~xml
<beans>
    <bean id="foo" class="x.y.Foo">
        <constructor-arg ref="bar"/>
        <constructor-arg ref="baz"/>
    </bean>

    <bean id="bar" class="x.y.Bar"/>

    <bean id="baz" class="x.y.Baz"/>
</beans>
~~~

#### Constructor argument type matching(생성자 인수 유형 일치)
**type 속성**을 사용하여 생성자 인수의 유형을 명시 적으로 지정하면  
컨테이너는 단순 유형과 일치하는 유형을 사용할 수 있습니다.  
예 :
~~~xml
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg type="int" value="7500000"/>
    <constructor-arg type="java.lang.String" value="42"/>
</bean>
~~~
#### Constructor argument index(생성자 인수 인덱스)
**index 속성**을 사용하여 생성자 인수 인덱스를 명시 적으로 지정합니다.  
예 :
~~~xml
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg index="0" value="7500000"/>
    <constructor-arg index="1" value="42"/>
</bean>
~~~
여러 간단한 값의 모호성을 해결하는 것 외에도  
**인덱스를 지정**하면 **생성자가 동일한 유형의 인수가 두 개인 모호성이 해결**됩니다.  
**인덱스는 0을 기준**으로 합니다.  

#### Constructor argument name(생성자 인수 이름)
또한 값의 모호성 제거를 위해 생성자 매개 변수 이름을 사용할 수 있습니다.  
~~~xml
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg name="years" value="7500000"/>
    <constructor-arg name="ultimateAnswer" value="42"/>
</bean>
~~~
이 작업을 수행하려면 Spring이 생성자에서 매개 변수 이름을 찾을 수 있도록  
`debug flag`를 사용해서 코드를 컴파일해야합니다.  
`debug flag`로 코드를 컴파일 할 수 없다면  
`@ConstructorProperties` *JDK 어노테이션을 사용하여* **생성자 인수의 이름을 명시적으로 지정**할 수 있습니다.  
샘플 클래스는 다음과 같이 보일 것입니다.  
~~~java
package examples;

public class ExampleBean {

    // Fields 생략

    @ConstructorProperties({"years", "ultimateAnswer"})
    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }
}
~~~

### Setter-based dependency injection(Setter 기반의 의존성 주입)
> **Setter 기반 DI**는 **빈을 인스턴스화하기 위해**  
> **인수가 없는 생성자** 또는 **인수가 없는 정적 팩토리 메소드**를 호출 한 후  
> **Setter 메소드를 호출하는 컨테이너에 의해 수행**됩니다.  

다음 예제에서는 **순수한 setter 주입을 사용**하여 **종속성 주입만 할 수있는 클래스**를 보여줍니다.  
이 클래스는 일반적인 Java입니다.  
이것은 컨테이너 관련 인터페이스, 기본 클래스 또는 `annotation`에 대한 의존성이 없는 `POJO`입니다.

~~~java
public class SimpleMovieLister {

    // SimpleMovieLister는 MovieFinder에 의존합니다.
    private MovieFinder movieFinder;

    // Spring 컨테이너가 MovieFinder를 삽입 할 수 있도록하는 setter 메소드
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // 실제로 삽입 된 MovieFinder를 사용하는 비즈니스 로직은 생략됩니다 ...
}
~~~

`ApplicationContext`는 자신이 관리하는 `bean`에 대한  
`constructor-based`(생성자 기반) 및 `setter-based`(설정자 기반) DI를 지원합니다.  
또한 ***생성자 방식을 통해 이미 일부 종속성이 주입 된 후에도*** **setter 기반 DI를 지원**합니다.  

`PropertyEditor` 인스턴스와 함께 사용하여  
*하나의 형식에서 다른 형식으로 속성을 변환하는* `BeanDefinition` 형식으로 **종속성을 구성**합니다.  

그러나 대부분의 Spring 사용자는 이러한 클래스를 직접 (즉, 프로그래밍 방식으로) 사용하지 않고  
**XML bean 정의**, **annotation이 추가 된 구성 요소 (즉, @Component, @Controller 등으로 된 클래스)**  
또는 **Java 기반의 @Bean 메소드 @Configuration 클래스**를 사용합니다.  
이러한 소스는 내부적으로 `BeanDefinition`의 인스턴스로 변환되어  
**전체 `spring IoC 컨테이너 인스턴스`를 로드하는 데 사용**된다.

